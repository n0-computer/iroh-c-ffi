/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_IROH_NET_FFI__
#define __RUST_IROH_NET_FFI__
#ifdef __cplusplus
extern "C" {
#endif

/** \brief
 *  An endpoint that leverages a quic endpoint, backed by a magic socket.
 */
typedef struct MagicEndpoint MagicEndpoint_t;


#include <stddef.h>
#include <stdint.h>

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_uint8_t;

/** <No documentation available> */
typedef struct RecvStream RecvStream_t;

/** \brief
 *  Result of dealing with a magic endpoint.
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum MagicEndpointResult {
    /** \brief
     *  Everything is ok
     */
    MAGIC_ENDPOINT_RESULT_OK = 0,
    /** \brief
     *  Failed to bind.
     */
    MAGIC_ENDPOINT_RESULT_BIND_ERROR,
    /** \brief
     *  Failed to accept a uni directional stream,
     */
    MAGIC_ENDPOINT_RESULT_ACCEPT_UNI_FAILED,
    /** \brief
     *  Failed to connect and establish a uni directional stream.
     */
    MAGIC_ENDPOINT_RESULT_CONNECT_UNI_ERROR,
    /** \brief
     *  Unable to retrive node addr.
     */
    MAGIC_ENDPOINT_RESULT_ADDR_ERROR,
    /** \brief
     *  Error while sending data.
     */
    MAGIC_ENDPOINT_RESULT_SEND_ERROR,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
MagicEndpointResult_t;

/** \brief
 *  Accept a new connection and uni directinal stream on this endpoint.
 */
MagicEndpointResult_t
magic_endpoint_accept_uni (
    MagicEndpoint_t * const * ep,
    slice_ref_uint8_t expected_alpn,
    RecvStream_t * * out);

/** \brief
 *  The options to configure derp.
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum DerpMode {
    /** \brief
     *  Derp mode is entirely disabled
     */
    DERP_MODE_DISABLED,
    /** \brief
     *  Default derp map is used.
     */
    DERP_MODE_DEFAULT,
    /** \brief
     *  Default derp map, but only used for stun.
     *  Not yet implemented
     */
    DERP_MODE_STUN_ONLY,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
DerpMode_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_uint8 {
    /** <No documentation available> */
    uint8_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_uint8_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_Vec_uint8 {
    /** <No documentation available> */
    Vec_uint8_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_Vec_uint8_t;

/** \brief
 *  A secret key.
 */
typedef struct SecretKey SecretKey_t;

/** \brief
 *  Configuration options for the MagicEndpoint.
 */
typedef struct MagicEndpointConfig {
    /** <No documentation available> */
    DerpMode_t derp_mode;

    /** <No documentation available> */
    Vec_Vec_uint8_t alpn_protocols;

    /** <No documentation available> */
    SecretKey_t * secret_key;
} MagicEndpointConfig_t;

/** <No documentation available> */
MagicEndpointResult_t
magic_endpoint_bind (
    MagicEndpointConfig_t const * config,
    uint16_t port,
    MagicEndpoint_t * * out);

/** \brief
 *  Add the given ALPN to the list of accepted ALPNs.
 */
void
magic_endpoint_config_add_alpn (
    MagicEndpointConfig_t * config,
    slice_ref_uint8_t alpn);

/** \brief
 *  Generate a default magic endpoint configuration.
 *
 *  Must be freed using `magic_endpoing_config_free`.
 */
MagicEndpointConfig_t
magic_endpoint_config_default (void);

/** \brief
 *  Frees the magic endpoint config.
 */
void
magic_endpoint_config_free (
    MagicEndpointConfig_t config);

typedef struct {
    uint8_t idx[32];
} uint8_32_array_t;

/** \brief
 *  A public key.
 */
typedef struct PublicKey {
    /** <No documentation available> */
    uint8_32_array_t key;
} PublicKey_t;

/** \brief
 *  Represents a valid URL.
 */
typedef struct Url Url_t;

/** \brief
 *  Represents an IPv4 or IPv6 address, including a port number.
 */
typedef struct SocketAddr SocketAddr_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_SocketAddr_ptr {
    /** <No documentation available> */
    SocketAddr_t * * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_SocketAddr_ptr_t;

/** \brief
 *  A peer and it's addressing information.
 */
typedef struct NodeAddr {
    /** \brief
     *  The node's public key.
     */
    PublicKey_t node_id;

    /** \brief
     *  The peer's home DERP url.
     */
    Url_t * derp_url;

    /** \brief
     *  Socket addresses where the peer might be reached directly.
     */
    Vec_SocketAddr_ptr_t direct_addresses;
} NodeAddr_t;

/** <No documentation available> */
typedef struct SendStream SendStream_t;

/** <No documentation available> */
MagicEndpointResult_t
magic_endpoint_connect_uni (
    MagicEndpoint_t * const * ep,
    slice_ref_uint8_t alpn,
    NodeAddr_t node_addr,
    SendStream_t * * out);

/** \brief
 *  Generate a default endpoint.
 *
 *  Must be freed using `magic_endpoint_free`.
 */
MagicEndpoint_t *
magic_endpoint_default (void);

/** \brief
 *  Frees the magic endpoint.
 */
void
magic_endpoint_free (
    MagicEndpoint_t * ep);

/** <No documentation available> */
MagicEndpointResult_t
magic_endpoint_my_addr (
    MagicEndpoint_t * const * ep,
    NodeAddr_t * out);

/** \brief
 *  Must be freed using `magic_endpoint_recv_stream_free`
 */
RecvStream_t *
magic_endpoint_recv_stream_default (void);

/** \brief
 *  Free the recv stream.
 */
void
magic_endpoint_recv_stream_free (
    RecvStream_t * stream);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_uint8 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_uint8_t;

/** \brief
 *  Recv data on the stream.
 *
 *  Returns how many bytes were read. Returns `-1` if an error occured.
 */
int64_t
magic_endpoint_recv_stream_read (
    RecvStream_t * * stream,
    slice_mut_uint8_t data);

/** \brief
 *  Must be freed using `magic_endpoint_send_stream_free`
 */
SendStream_t *
magic_endpoint_send_stream_default (void);

/** \brief
 *  Finish the sending on this stream.
 *
 *  Consumes the send stream, no need to free it afterwards.
 */
MagicEndpointResult_t
magic_endpoint_send_stream_finish (
    SendStream_t * stream);

/** \brief
 *  Free the send stream.
 */
void
magic_endpoint_send_stream_free (
    SendStream_t * stream);

/** \brief
 *  Send data on the stream
 */
MagicEndpointResult_t
magic_endpoint_send_stream_write (
    SendStream_t * * stream,
    slice_ref_uint8_t data);

/** \brief
 *  Add a derp url to the peer's addr info.
 */
void
node_addr_add_derp_url (
    NodeAddr_t * addr,
    Url_t * derp_url);

/** \brief
 *  Add the given direct addresses to the peer's addr info.
 */
void
node_addr_add_direct_address (
    NodeAddr_t * node_addr,
    SocketAddr_t * address);

/** \brief
 *  Create a an empty (invalid) addr with no details.
 *
 *  Must be freed using `node_addr_free`.
 */
NodeAddr_t
node_addr_default (void);

/** \brief
 *  Get the derp url of this peer.
 */
Url_t * const *
node_addr_derp_url (
    NodeAddr_t const * addr);

/** \brief
 *  Get the nth direct addresses of this peer.
 *
 *  Panics if i is larger than the available addrs.
 */
SocketAddr_t const *
node_addr_direct_addresses_nth (
    NodeAddr_t const * addr,
    size_t i);

/** \brief
 *  Free the node addr.
 */
void
node_addr_free (
    NodeAddr_t node_addr);

/** \brief
 *  Create a new addr with no details.
 *
 *  Must be freed using `node_addr_free`.
 */
NodeAddr_t
node_addr_new (
    PublicKey_t node_id);

/** \brief
 *  Returns the public key as a base32 string.
 *
 *  Result must be freed using `rust_free_string`
 */
char *
public_key_as_base32 (
    PublicKey_t const * key);

/** \brief
 *  Generate a default (invalid) public key.
 *
 *  Result must be freed using `public_key_free`.
 */
PublicKey_t
public_key_default (void);

/** \brief
 *  Free the passed in key.
 */
void
public_key_free (
    PublicKey_t _key);

/** \brief
 *  Result of handling key material.
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum KeyResult {
    /** \brief
     *  Everything is ok.
     */
    KEY_RESULT_OK = 0,
    /** \brief
     *  Invalid public key material.
     */
    KEY_RESULT_INVALID_PUBLIC_KEY,
    /** \brief
     *  Invalid secret key material.
     */
    KEY_RESULT_INVALID_SECRET_KEY,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
KeyResult_t;

/** \brief
 *  Parses the public key from a base32 string.
 */
KeyResult_t
public_key_from_base32 (
    char const * raw_key,
    PublicKey_t * out);

/** \brief
 *  Frees a Rust-allocated string.
 */
void
rust_free_string (
    char * string);

/** \brief
 *  Returns the secret key as a base32 string.
 *
 *  Result must be freed using `rust_free_string`
 */
char *
secret_key_as_base32 (
    SecretKey_t const * key);

/** \brief
 *  Generate a default secret key.
 *
 *  Result must be freed using `secret_key_free`.
 */
SecretKey_t *
secret_key_default (void);

/** \brief
 *  Free the passed in key.
 */
void
secret_key_free (
    SecretKey_t * key);

/** \brief
 *  Parses the secret key from a base32 string.
 */
KeyResult_t
secret_key_from_base32 (
    char const * raw_key,
    SecretKey_t * * out);

/** \brief
 *  Generates a new key with default OS randomness.
 *
 *  Result must be freed using `secret_key_free`
 */
SecretKey_t *
secret_key_generate (void);

/** \brief
 *  The public key for this secret key.
 *
 *  Result must be freed using `public_key_free`
 */
PublicKey_t
secret_key_public (
    SecretKey_t const * key);

/** \brief
 *  Formats the given socket addr as a string
 *
 *  Result must be freed with `rust_free_string`
 */
char *
socket_addr_as_str (
    SocketAddr_t const * addr);

/** <No documentation available> */
SocketAddr_t *
socket_addr_default (void);

/** <No documentation available> */
void
socket_addr_free (
    SocketAddr_t * addr);

/** <No documentation available> */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum AddrResult {
    /** \brief
     *  Everything is ok.
     */
    ADDR_RESULT_OK = 0,
    /** \brief
     *  Url was invalid.
     */
    ADDR_RESULT_INVALID_URL,
    /** \brief
     *  SocketAddr was invalid.
     */
    ADDR_RESULT_INVALID_SOCKET_ADDR,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
AddrResult_t;

/** \brief
 *  Try to parse a url from a string.
 */
AddrResult_t
socket_addr_from_string (
    char const * input,
    SocketAddr_t * * out);

/** \brief
 *  Formats the given url as a string
 *
 *  Result must be freed with `rust_free_string`
 */
char *
url_as_str (
    Url_t const * url);

/** \brief
 *  Creates an initialized but invalid Url.
 */
Url_t *
url_default (void);

/** \brief
 *  Try to parse a url from a string.
 */
AddrResult_t
url_from_string (
    char const * input,
    Url_t * * out);


#ifdef __cplusplus
} /* extern \"C\" */
#endif

#endif /* __RUST_IROH_NET_FFI__ */
